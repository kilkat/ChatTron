let mcpToolRegistry = {};
let llmToolMatchingPrompt = ""; // LLM ÎèÑÍµ¨ Îß§Ïπ≠ ÌîÑÎ°¨ÌîÑÌä∏ ÎÇ¥Ïö©ÏùÑ Ï†ÄÏû•Ìï† Î≥ÄÏàò
let systemPrompt = ""; // ÏãúÏä§ÌÖú ÌîÑÎ°¨ÌîÑÌä∏ ÎÇ¥Ïö©ÏùÑ Ï†ÄÏû•Ìï† Î≥ÄÏàò

// --- ÌååÏùº ÏóÖÎ°úÎìú Í¥ÄÎ†® Î≥ÄÏàò Î∞è Ìï®Ïàò ÏãúÏûë ---
let uploadedFiles = []; // ÏóÖÎ°úÎìúÎêú ÌååÏùºÎì§ÏùÑ Ï†ÄÏû•Ìï† Î∞∞Ïó¥
const fileInput = document.getElementById("file-input");
const attachBtn = document.getElementById("attach-btn");
const uploadedFilesList = document.getElementById("uploaded-files-list");
const fileUploadSection = document.getElementById("file-upload-section");
const clearAllFilesBtn = document.getElementById("clear-all-files-btn");
const chatPanel = document.getElementById("chat-panel"); // chatPanel ÏöîÏÜå Ï∂îÍ∞Ä

// ÌååÏùº Î™©Î°ù UI ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
function updateUploadedFilesUI() {
  uploadedFilesList.innerHTML = ""; // Í∏∞Ï°¥ Î™©Î°ù Ï¥àÍ∏∞Ìôî
  if (uploadedFiles.length > 0) {
    fileUploadSection.classList.remove("hidden");
    clearAllFilesBtn.classList.remove("hidden");
    uploadedFiles.forEach((file, index) => {
      const fileTag = document.createElement("div");
      fileTag.className =
        "flex items-center bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-1 rounded-full dark:bg-blue-900 dark:text-blue-300 mr-1 mb-1";
      fileTag.innerHTML = `
        <span>${file.name}</span>
        <button type="button" class="ml-2 text-blue-800 hover:text-blue-900" data-file-index="${index}">
          √ó
        </button>
      `;
      uploadedFilesList.appendChild(fileTag);
    });
  } else {
    fileUploadSection.classList.add("hidden");
    clearAllFilesBtn.classList.add("hidden");
  }
}

// Ï≤®Î∂Ä ÌååÏùº Î™©Î°ùÏùÑ Ï¥àÍ∏∞ÌôîÌïòÎäî ÏÉàÎ°úÏö¥ Ìï®Ïàò
function clearAttachedFiles() {
  uploadedFiles = [];
  fileInput.value = ""; // ÌååÏùº ÏûÖÎ†• ÌïÑÎìúÏùò Í∞íÎèÑ Ï¥àÍ∏∞Ìôî
  updateUploadedFilesUI();
  console.log("Attached files cleared.");
}

// Îã®Ïùº ÌååÏùº ÏÇ≠Ï†ú Ìï∏Îì§Îü¨
uploadedFilesList.addEventListener("click", (event) => {
  if (event.target.tagName === "BUTTON") {
    const index = parseInt(event.target.dataset.fileIndex);
    if (!isNaN(index)) {
      uploadedFiles.splice(index, 1); // Î∞∞Ïó¥ÏóêÏÑú ÌååÏùº Ï†úÍ±∞
      updateUploadedFilesUI(); // UI ÏóÖÎç∞Ïù¥Ìä∏
    }
  }
});

// "Î™®Îëê ÏÇ≠Ï†ú" Î≤ÑÌäº Ìï∏Îì§Îü¨
clearAllFilesBtn.addEventListener("click", () => {
  clearAttachedFiles(); // ÏÉà Ìï®Ïàò Ìò∏Ï∂ú
});

// "Attach" Î≤ÑÌäº ÌÅ¥Î¶≠ Ïãú Ïà®Í≤®ÏßÑ ÌååÏùº ÏûÖÎ†• ÌïÑÎìú Ìä∏Î¶¨Í±∞
attachBtn?.addEventListener("click", () => {
  fileInput.click();
});

// ÌååÏùº ÏûÖÎ†• ÌïÑÎìú Î≥ÄÍ≤Ω Ïãú (ÌååÏùº ÏÑ†ÌÉù ÏôÑÎ£å)
fileInput.addEventListener("change", (event) => {
  const files = event.target.files;
  if (files.length > 0) {
    uploadedFiles = [...uploadedFiles, ...Array.from(files)];
    updateUploadedFilesUI();
    console.log("Attached Files:", uploadedFiles);
  }
});

// --- ÎìúÎûòÍ∑∏ Ïï§ ÎìúÎ°≠ Ìï∏Îì§Îü¨ ÏãúÏûë ---
chatPanel?.addEventListener("dragover", (event) => {
  event.preventDefault(); // Í∏∞Î≥∏ ÎèôÏûë Î∞©ÏßÄ
  chatPanel.classList.add("border-blue-500", "border-2", "border-dashed"); // ÏãúÍ∞ÅÏ†Å ÌîºÎìúÎ∞± Ï∂îÍ∞Ä
});

chatPanel?.addEventListener("dragleave", (event) => {
  event.preventDefault(); // Í∏∞Î≥∏ ÎèôÏûë Î∞©ÏßÄ
  chatPanel.classList.remove("border-blue-500", "border-2", "border-dashed"); // ÏãúÍ∞ÅÏ†Å ÌîºÎìúÎ∞± Ï†úÍ±∞
});

chatPanel?.addEventListener("drop", (event) => {
  event.preventDefault(); // Í∏∞Î≥∏ ÎèôÏûë Î∞©ÏßÄ
  chatPanel.classList.remove("border-blue-500", "border-2", "border-dashed"); // ÏãúÍ∞ÅÏ†Å ÌîºÎìúÎ∞± Ï†úÍ±∞

  const files = event.dataTransfer.files; // ÎìúÎ°≠Îêú ÌååÏùº Í∞ÄÏ†∏Ïò§Í∏∞
  if (files.length > 0) {
    uploadedFiles = [...uploadedFiles, ...Array.from(files)]; // ÌååÏùº Ï∂îÍ∞Ä
    updateUploadedFilesUI(); // UI ÏóÖÎç∞Ïù¥Ìä∏
    console.log("Dropped Files:", uploadedFiles);
  }
});
// --- ÎìúÎûòÍ∑∏ Ïï§ ÎìúÎ°≠ Ìï∏Îì§Îü¨ ÎÅù ---

// --- ÌååÏùº ÏóÖÎ°úÎìú Í¥ÄÎ†® Î≥ÄÏàò Î∞è Ìï®Ïàò ÎÅù ---

async function findToolViaLLM(prompt, tools) {
  const settings =
    window.settingsAPI?.load?.() ||
    JSON.parse(localStorage.getItem("chattron-settings") || "{}");

  const { apiUrl, modelName, apiKey, provider } = settings;
  if (!apiUrl || !modelName || !provider) {
    console.warn("‚ùó LLM configuration missing.");
    return null;
  }

  // MCP tool Î™©Î°ùÏóêÏÑú client/toolName ÏûêÎèô Ï∂îÏ∂ú
  const clientSet = new Set();
  const toolSet = new Set();

  for (const [client, toolList] of Object.entries(tools)) {
    clientSet.add(client);
    for (const tool of toolList) {
      toolSet.add(tool.name);
    }
  }

  const clientList = Array.from(clientSet);
  const toolList = Array.from(toolSet);

  // ÌÜµÌï©Îêú ÌîÑÎ°¨ÌîÑÌä∏ - Îã®Ïùº/Îã§Ï§ë ÏûêÎèô ÌåêÎã®
  // ÌïòÎìúÏΩîÎî©Îêú Î¨∏ÏûêÏó¥ ÎåÄÏã† Î°úÎìúÎêú llmToolMatchingPrompt ÏÇ¨Ïö©
  const formattedLlmPrompt = llmToolMatchingPrompt
    .replace("{{CLIENT_LIST}}", JSON.stringify(clientList, null, 2))
    .replace("{{TOOL_LIST}}", JSON.stringify(toolList, null, 2))
    .replace("{{USER_PROMPT}}", prompt);

  const payload = {
    model: modelName,
    messages: [
      {
        role: "system",
        content:
          "You are a tool selector. Return either a single JSON object for one tool or a JSON array for multiple tools. Do NOT add any comments or explanatory text.",
      },
      { role: "user", content: formattedLlmPrompt },
    ],
    stream: false,
  };

  const headers = {
    "Content-Type": "application/json",
    ...(apiKey && { Authorization: `Bearer ${apiKey}` }),
  };

  // ÌÜµÌï©Îêú JSON Ï∂îÏ∂ú Ìï®Ïàò - Í∞ùÏ≤¥ ÎòêÎäî Î∞∞Ïó¥ Ï≤òÎ¶¨
  function extractToolDataFromText(text) {
    console.log("üîç Extracting tool data from text:", text);

    // 1. Ï†ÑÏ≤¥ ÌÖçÏä§Ìä∏Í∞Ä JSONÏù∏ÏßÄ ÌôïÏù∏ (Í∞ùÏ≤¥ ÎòêÎäî Î∞∞Ïó¥)
    try {
      const trimmedText = text.trim();
      const parsed = JSON.parse(trimmedText);

      // Î∞∞Ïó¥Ïù∏ Í≤ΩÏö∞
      if (Array.isArray(parsed)) {
        const validArray = parsed.filter(
          (item) =>
            item.client && item.toolName && typeof item.args === "object"
        );
        if (validArray.length > 0) {
          console.log("‚úÖ Direct array parse successful:", validArray);
          return { type: "multiple", tools: validArray };
        }
      }
      // Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞
      else if (
        parsed.client &&
        parsed.toolName &&
        typeof parsed.args === "object"
      ) {
        console.log("‚úÖ Direct object parse successful:", parsed);
        return { type: "single", tool: parsed };
      }
    } catch (e) {
      console.log("‚ö†Ô∏è Direct JSON parse failed, trying alternatives...");
    }

    // 2. Markdown code block Ï∂îÏ∂ú
    const markdownMatch = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/i);
    if (markdownMatch) {
      try {
        const parsed = JSON.parse(markdownMatch[1]);

        if (Array.isArray(parsed)) {
          const validArray = parsed.filter(
            (item) =>
              item.client && item.toolName && typeof item.args === "object"
          );
          if (validArray.length > 0) {
            console.log("‚úÖ Markdown array parse successful:", validArray);
            return { type: "multiple", tools: validArray };
          }
        } else if (
          parsed.client &&
          parsed.toolName &&
          typeof parsed.args === "object"
        ) {
          console.log("‚úÖ Markdown object parse successful:", parsed);
          return { type: "single", tool: parsed };
        }
      } catch (e) {
        console.warn(
          "‚ö†Ô∏è JSON parse failed from markdown block:",
          markdownMatch[1]
        );
      }
    }

    // 3. Î∞∞Ïó¥ Ìå®ÌÑ¥ Î®ºÏ†Ä Ï∞æÍ∏∞ (ÎåÄÍ¥ÑÌò∏Î°ú ÏãúÏûë)
    const arrayMatch = text.match(/\[[\s\S]*\]/);
    if (arrayMatch) {
      try {
        const parsed = JSON.parse(arrayMatch[0]);
        if (Array.isArray(parsed)) {
          const validArray = parsed.filter(
            (item) =>
              item.client && item.toolName && typeof item.args === "object"
          );
          if (validArray.length > 0) {
            console.log("‚úÖ Array pattern parse successful:", validArray);
            return { type: "multiple", tools: validArray };
          }
        }
      } catch (e) {
        console.log("‚ö†Ô∏è Array pattern parse failed:", e.message);
      }
    }

    // 4. Í∞ùÏ≤¥ Ìå®ÌÑ¥ Ï∞æÍ∏∞ (Ï§ëÍ¥ÑÌò∏ Î∏îÎ°ùÎì§)
    const jsonBlocks = [...text.matchAll(/\{[\s\S]*?\}/g)];
    console.log(`üîç Found ${jsonBlocks.length} potential JSON blocks`);

    // Ïó¨Îü¨ Í∞ùÏ≤¥Í∞Ä ÏûàÏúºÎ©¥ Î∞∞Ïó¥Î°ú Ï≤òÎ¶¨
    const validObjects = [];
    for (const match of jsonBlocks) {
      try {
        const jsonText = match[0];
        const json = JSON.parse(jsonText);

        if (json.client && json.toolName && typeof json.args === "object") {
          validObjects.push(json);
        }
      } catch (e) {
        continue;
      }
    }

    if (validObjects.length > 1) {
      console.log(
        "‚úÖ Multiple objects found, treating as array:",
        validObjects
      );
      return { type: "multiple", tools: validObjects };
    } else if (validObjects.length === 1) {
      console.log("‚úÖ Single object found:", validObjects[0]);
      return { type: "single", tool: validObjects[0] };
    }

    console.log("‚ùå No valid tool data found in text");
    return null;
  }

  try {
    console.log("üõ∞Ô∏è Sending request to LLM:", { apiUrl, modelName, provider });

    const startTime = Date.now();

    const res = await fetch(apiUrl, {
      method: "POST",
      headers,
      body: JSON.stringify(payload),
    });

    const responseTime = Date.now() - startTime;
    console.log(`‚è±Ô∏è Response received in ${responseTime}ms`);

    if (!res.ok) {
      const errorText = await res.text();
      console.error("‚ùå HTTP Error Response:", {
        status: res.status,
        statusText: res.statusText,
        body: errorText,
      });
      throw new Error(`HTTP ${res.status}: ${errorText}`);
    }

    const data = await res.json();
    console.log("üßæ Full LLM response JSON object:", data);

    const text =
      data.choices?.[0]?.message?.content ||
      data.message?.content ||
      data.content ||
      data.response ||
      "";

    console.log("üì© Raw LLM response text:\n", text);

    const result = extractToolDataFromText(text);

    if (result) {
      // Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù Î∞è Í∏∞Ï°¥ Íµ¨Ï°∞Ïóê ÎßûÍ≤å Î∞òÌôò
      if (result.type === "single") {
        const tool = result.tool;
        const validClient = clientList.includes(tool.client);
        const validTool = toolList.includes(tool.toolName);

        if (validClient && validTool) {
          console.log("‚úÖ Single tool validated:", tool);
          // Í∏∞Ï°¥ Íµ¨Ï°∞Ïóê ÎßûÍ≤å Î∞òÌôò (client, toolName, args)
          return {
            client: tool.client,
            toolName: tool.toolName,
            args: tool.args,
          };
        } else {
          console.warn("‚ùå Single tool validation failed:", {
            validClient,
            validTool,
            tool,
          });
        }
      } else if (result.type === "multiple") {
        const validTools = result.tools.filter(
          (tool) =>
            clientList.includes(tool.client) && toolList.includes(tool.toolName)
        );

        if (validTools.length > 0) {
          console.log(
            `‚úÖ ${validTools.length}/${result.tools.length} tools validated:`,
            validTools
          );

          if (validTools.length < result.tools.length) {
            console.warn(
              `‚ö†Ô∏è ${
                result.tools.length - validTools.length
              } tools were filtered out due to validation failure`
            );
          }

          // Îã§Ï§ë ÎèÑÍµ¨ ÌëúÏãúÎ•º ÏúÑÌï¥ ÌäπÎ≥ÑÌïú Íµ¨Ï°∞Î°ú Î∞òÌôò
          return {
            isMultiple: true,
            tools: validTools,
            totalCount: validTools.length,
          };
        } else {
          console.warn("‚ùå No tools passed validation:", result.tools);
        }
      }
    }

    console.warn("‚ùå No valid tool configuration found");
    return null;
  } catch (err) {
    console.error("üö® LLM tool matching error:", err);
    return null;
  }
}

// Îã§Ï§ë MCP ÎèÑÍµ¨ Ïã§Ìñâ Ìï®Ïàò
async function executeMultipleTools(toolsConfig, prompt) {
  const { tools, totalCount } = toolsConfig;

  console.log(`üîÑ Executing ${totalCount} tools sequentially...`);

  const results = [];

  for (let i = 0; i < tools.length; i++) {
    const tool = tools[i];

    console.log(`üìç Executing tool ${i + 1}/${totalCount}:`, {
      client: tool.client,
      toolName: tool.toolName,
      args: tool.args,
    });

    // Í∞Å ÎèÑÍµ¨Î≥Ñ Ïã§Ìñâ Î©îÏãúÏßÄ ÌëúÏãú
    const executingMessage = renderMessage(
      `üõ†Ô∏è Executing tool ${i + 1}/${totalCount}: ${tool.client}/${
        tool.toolName
      }...`,
      "system"
    );

    try {
      console.log("MCP CALL DEBUG", {
        client: tool.client,
        name: tool.toolName,
        args: tool.args,
      });

      const result = await window.mcpAPI.callTool({
        client: tool.client,
        name: tool.toolName,
        args: tool.args,
      });

      // Ïã§Ìñâ Î©îÏãúÏßÄ Ï†úÍ±∞
      if (executingMessage && executingMessage.parentNode) {
        executingMessage.remove();
      }

      // Í≤∞Í≥º ÌëúÏãú
      const resultMessage = `[${i + 1}/${totalCount}] ${tool.client}/${
        tool.toolName
      }: ${JSON.stringify(result, null, 2)}`;
      renderMessage(resultMessage, "assistant");

      results.push({
        index: i + 1,
        success: true,
        client: tool.client,
        toolName: tool.toolName,
        result: result,
      });

      console.log(`‚úÖ Tool ${i + 1} executed successfully`);

      // ÎèÑÍµ¨ Ïã§Ìñâ ÏÇ¨Ïù¥Ïóê ÏßÄÏó∞ (Î∏åÎùºÏö∞Ï†Ä ÏûëÏóÖÏùò Í≤ΩÏö∞ Ïú†Ïö©)
      if (i < tools.length - 1) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    } catch (err) {
      console.error(`‚ùå Tool ${i + 1} execution failed:`, err);

      // Ïã§Ìñâ Î©îÏãúÏßÄ Ï†úÍ±∞
      if (executingMessage && executingMessage.parentNode) {
        executingMessage.remove();
      }

      // ÏóêÎü¨ Î©îÏãúÏßÄ ÌëúÏãú
      const errorMessage = `[${i + 1}/${totalCount}] ${tool.client}/${
        tool.toolName
      } Error: ${err.message}`;
      renderMessage(errorMessage, "system");

      results.push({
        index: i + 1,
        success: false,
        client: tool.client,
        toolName: tool.toolName,
        error: err.message,
      });

      // Ïã§Ìå®Ìïú Í≤ΩÏö∞ÏóêÎèÑ Í≥ÑÏÜç ÏßÑÌñâ (ÏÑ§Ï†ïÏóê Îî∞Îùº Ï§ëÎã®ÌïòÎ†§Î©¥ break ÏÇ¨Ïö©)
      // break;
    }
  }

  // Ï†ÑÏ≤¥ Ïã§Ìñâ Í≤∞Í≥º ÏöîÏïΩ
  const successCount = results.filter((r) => r.success).length;
  const summary = `‚úÖ Multi-tool execution completed: ${successCount}/${totalCount} tools succeeded`;

  console.log("üéâ Multi-tool execution summary:", {
    results,
    successCount,
    totalCount,
  });

  // ÏöîÏïΩÏùÑ ÌûàÏä§ÌÜ†Î¶¨Ïóê Ï†ÄÏû•
  saveToHistory(prompt, summary);

  return results;
}

// ÏàòÏ†ïÎêú MCP ÎèôÍ∏∞Ìôî ÏΩîÎìú -> Í∏∞Ï°¥Ïóê Session Storage ÏÇ≠Ï†úÎèÑ Ï†úÎåÄÎ°ú ÏïàÎêòÏóàÍ≥†, ÎèôÍ∏∞ÌôîÏóê Î¨∏Ï†úÍ∞Ä ÏûàÏñ¥ ÌÜ†Í∏ÄÏùÑ Í∫ºÎèÑ MCPÍ∞Ä ÌôúÏÑ±Ìôî ÎêòÏñ¥ ÏûàÎäî ÏÉÅÌÉúÎ°ú ÎÇ®ÏïÑ ÏûàÎäî Í≤ΩÏö∞Í∞Ä ÏûàÏóàÏùå
// 1. Í∞úÏÑ†Îêú buildMCPRegistry Ìï®Ïàò - sessionStorage Í∏∞Î∞òÏúºÎ°ú Î≥ÄÍ≤Ω
async function buildMCPRegistry() {
  mcpToolRegistry = {};

  // sessionStorageÏóêÏÑú ÌôúÏÑ±ÌôîÎêú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
  const activeClients =
    JSON.parse(sessionStorage.getItem("active-clients")) || [];

  console.log("üîß Building registry for active clients:", activeClients);

  for (const clientKey of activeClients) {
    try {
      // Ïã§Ï†ú Î∞±ÏóîÎìúÏóêÏÑú Ìï¥Îãπ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Í∞Ä ÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÎäîÏßÄ ÌôïÏù∏
      const backendClients = await window.mcpAPI.getClients();

      if (backendClients.includes(clientKey)) {
        const { tools } = await window.mcpAPI.listTools(clientKey);
        mcpToolRegistry[clientKey] = tools || [];
        console.log(`‚úÖ Added ${clientKey} with ${tools?.length || 0} tools`);
      } else {
        console.warn(`‚ö†Ô∏è Client ${clientKey} not active in backend, skipping`);
        // sessionStorageÏóêÏÑúÎèÑ Ï†úÍ±∞
        const updatedActiveClients = activeClients.filter(
          (c) => c !== clientKey
        );
        sessionStorage.setItem(
          "active-clients",
          JSON.stringify(updatedActiveClients)
        );
      }
    } catch (err) {
      console.warn(`‚ùå Tool fetch failed for ${clientKey}:`, err);
      // Ïã§Ìå®Ìïú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏Îäî registryÏóêÏÑú Ï†úÏô∏
    }
  }

  console.log("üìã Registry built:", Object.keys(mcpToolRegistry));
}

// 2. Í∞úÏÑ†Îêú updateMCPUI Ìï®Ïàò - Ïã§Ï†ú Î∞±ÏóîÎìúÏôÄ ÎèôÍ∏∞Ìôî
async function updateMCPUI() {
  const panel = document.getElementById("mcp-panel");
  if (!panel) return;

  const serverList =
    JSON.parse(sessionStorage.getItem("mcp-server-list")) || [];
  const activeClients =
    JSON.parse(sessionStorage.getItem("active-clients")) || [];

  panel.innerHTML = "";

  serverList.forEach((server) => {
    const key = server.key;
    const isActive = activeClients.includes(key);

    const div = document.createElement("div");
    div.className =
      "flex items-center justify-between gap-2 px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm";
    div.innerHTML = `
      <span>${server.name || key}</span>
      <label class="inline-flex items-center cursor-pointer">
        <input type="checkbox" class="sr-only peer" data-mcp-key="${key}" ${
      isActive ? "checked" : ""
    }>
        <div class="w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:bg-green-500"></div>
      </label>
    `;

    div.addEventListener("click", (e) => {
      if (
        e.target.closest("label") ||
        e.target.tagName.toLowerCase() === "input"
      ) {
        return;
      }
      sessionStorage.setItem("selected-mcp-key", key);
      window.location.href = "mcp.html";
    });

    panel.appendChild(div);
  });

  // ÌÜ†Í∏Ä Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ - Ïã§Ï†ú Î∞±ÏóîÎìúÏôÄ ÎèôÍ∏∞Ìôî
  panel.querySelectorAll("input[data-mcp-key]").forEach((toggle) => {
    toggle.onchange = async () => {
      const key = toggle.dataset.mcpKey;
      let activeClients =
        JSON.parse(sessionStorage.getItem("active-clients")) || [];

      try {
        if (toggle.checked) {
          console.log(`üîµ Activating MCP client: ${key}`);

          // Î∞±ÏóîÎìúÏóêÏÑú Ïã§Ï†ú ÌôúÏÑ±Ìôî
          await window.mcpAPI.activate(key);

          // ÏÑ±Í≥µÌïòÎ©¥ sessionStorageÏóê Ï∂îÍ∞Ä
          if (!activeClients.includes(key)) {
            activeClients.push(key);
          }

          console.log(`‚úÖ Successfully activated: ${key}`);
        } else {
          console.log(`üî¥ Deactivating MCP client: ${key}`);

          // Î∞±ÏóîÎìúÏóêÏÑú Ïã§Ï†ú ÎπÑÌôúÏÑ±Ìôî
          await window.mcpAPI.deactivate(key);

          // ÏÑ±Í≥µÌïòÎ©¥ sessionStorageÏóêÏÑú Ï†úÍ±∞
          activeClients = activeClients.filter((c) => c !== key);

          console.log(`‚úÖ Successfully deactivated: ${key}`);
        }

        // sessionStorage ÏóÖÎç∞Ïù¥Ìä∏
        sessionStorage.setItem("active-clients", JSON.stringify(activeClients));

        // Registry Ïû¨Íµ¨ÏÑ±
        await buildMCPRegistry();

        // UI Ïû¨ÏóÖÎç∞Ïù¥Ìä∏
        updateMCPUI();
      } catch (error) {
        console.error(
          `‚ùå Failed to ${toggle.checked ? "activate" : "deactivate"} ${key}:`,
          error
        );

        // Ïã§Ìå®Ïãú ÌÜ†Í∏Ä ÏÉÅÌÉú ÎêòÎèåÎ¶¨Í∏∞
        toggle.checked = !toggle.checked;

        alert(
          `Failed to ${toggle.checked ? "activate" : "deactivate"} ${key}: ${
            error.message
          }`
        );
      }
    };
  });
}

// 3. Ï¥àÍ∏∞ ÎèôÍ∏∞Ìôî Ìï®Ïàò - Ïï± ÏãúÏûëÏãú Î∞±ÏóîÎìúÏôÄ sessionStorage ÎèôÍ∏∞Ìôî
async function syncMCPState() {
  try {
    console.log("üîÑ Syncing MCP state...");

    // Î∞±ÏóîÎìúÏóêÏÑú Ïã§Ï†ú ÌôúÏÑ±ÌôîÎêú ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
    const backendActiveClients = await window.mcpAPI.getClients();

    // sessionStorage ÏóÖÎç∞Ïù¥Ìä∏
    sessionStorage.setItem(
      "active-clients",
      JSON.stringify(backendActiveClients)
    );

    console.log("‚úÖ MCP state synced:", backendActiveClients);

    // Registry ÎπåÎìú
    await buildMCPRegistry();

    // UI ÏóÖÎç∞Ïù¥Ìä∏
    updateMCPUI();
  } catch (error) {
    console.error("‚ùå Failed to sync MCP state:", error);
  }
}

function findMatchingTool(prompt) {
  const lower = prompt.toLowerCase();

  for (const [clientKey, tools] of Object.entries(mcpToolRegistry)) {
    for (const tool of tools) {
      const keywords = [tool.name, tool.description];
      if (keywords.some((kw) => lower.includes(kw.toLowerCase()))) {
        return { client: clientKey, tool };
      }
    }
  }

  return null;
}

function extractArgsFromPrompt(prompt, inputSchema) {
  const args = {};
  const props = inputSchema?.properties || {};

  for (const key of Object.keys(props)) {
    const match = new RegExp(`${key}\\s*[:=]\\s*([^\\s]+)`, "i").exec(prompt);
    if (match) args[key] = match[1];
  }

  return args;
}

function renderMessage(text, sender) {
  const chatPanel = document.getElementById("chat-panel");
  const msg = document.createElement("div");

  msg.className = `my-2 p-3 rounded-lg max-w-[80%] whitespace-pre-wrap ${
    sender === "user"
      ? "bg-blue-100 self-end"
      : sender === "assistant"
      ? "bg-gray-200 self-start"
      : "bg-yellow-100 text-red-700 self-center"
  }`;
  msg.textContent = text;
  chatPanel.appendChild(msg);
  msg.scrollIntoView({ behavior: "smooth", block: "end" });

  const welcomeHeading = chatPanel.querySelector("h2");
  const welcomeText = chatPanel.querySelector("p");
  if (welcomeHeading) welcomeHeading.remove();
  if (welcomeText) welcomeText.remove();

  // DOM ÏöîÏÜåÎ•º Î∞òÌôò
  return msg;
}

function getCurrentSessionId() {
  let sessionId = sessionStorage.getItem("current-session-id");
  if (!sessionId) {
    sessionId = crypto.randomUUID();
    sessionStorage.setItem("current-session-id", sessionId);
    console.log("New session ID created:", sessionId);
  }
  return sessionId;
}

function saveToHistory(prompt, reply) {
  const sessionId = getCurrentSessionId();
  const allHistory = JSON.parse(
    localStorage.getItem("chattron-history") || "{}"
  );
  if (!allHistory[sessionId]) allHistory[sessionId] = [];
  allHistory[sessionId].push({
    prompt,
    reply,
    timestamp: new Date().toISOString(),
  });
  localStorage.setItem("chattron-history", JSON.stringify(allHistory));
  updateHistoryUI();
}

function loadHistory() {
  const sessionId = getCurrentSessionId();
  const allHistory = JSON.parse(
    localStorage.getItem("chattron-history") || "{}"
  );
  const history = allHistory[sessionId] || [];
  history.forEach(({ prompt, reply }) => {
    renderMessage(prompt, "user");
    renderMessage(reply, "assistant");
  });
}

function updateHistoryUI() {
  const panel = document.getElementById("history-panel");
  if (!panel) return;
  panel.innerHTML = "";

  const allHistory = JSON.parse(
    localStorage.getItem("chattron-history") || "{}"
  );

  Object.entries(allHistory).forEach(([sessionId, messages]) => {
    if (!Array.isArray(messages) || messages.length === 0) return;

    const firstPrompt = messages[0]?.prompt || "(empty)";
    const item = document.createElement("div");
    item.className =
      "flex items-center justify-between gap-2 px-3 py-2 hover:bg-gray-100 cursor-pointer text-sm";

    item.onclick = () => {
      sessionStorage.setItem("current-session-id", sessionId);
      const chatPanel = document.getElementById("chat-panel");
      chatPanel.innerHTML = "";
      // Welcome Î©îÏãúÏßÄ Î≥µÏõê (ÌååÏùº ÏóÖÎ°úÎìú ÏÑπÏÖò ÏïÑÎûòÏóê)
      chatPanel.innerHTML = `
        <h2 class="text-[28px] font-bold text-center pt-5 pb-3 text-[#0d141c]">Welcome to ChatTron</h2>
        <p class="text-base font-normal text-center pb-3 pt-1 text-[#0d141c]">
          Start a new chat or continue from your history.
        </p>
      `;
      loadHistory();
      // ÌûàÏä§ÌÜ†Î¶¨ Î°úÎìú ÌõÑ ÌååÏùº UIÎäî Ï¥àÍ∏∞Ìôî ÏÉÅÌÉúÎ°ú
      clearAttachedFiles(); // ÏÉà Ìï®Ïàò Ìò∏Ï∂ú
    };

    const textSpan = document.createElement("span");
    textSpan.textContent = firstPrompt;

    const deleteBtn = document.createElement("button");
    deleteBtn.textContent = "‚úñ";
    deleteBtn.className = "text-red-500 hover:text-red-700 ml-2";
    deleteBtn.onclick = (e) => {
      e.stopPropagation();
      delete allHistory[sessionId];
      localStorage.setItem("chattron-history", JSON.stringify(allHistory));
      updateHistoryUI();
      if (getCurrentSessionId() === sessionId) {
        const chatPanel = document.getElementById("chat-panel");
        chatPanel.innerHTML = `
          <h2 class="text-[28px] font-bold text-center pt-5 pb-3 text-[#0d141c]">Welcome to ChatTron</h2>
          <p class="text-base font-normal text-center pb-3 pt-1 text-[#0d141c]">
            Start a new chat or continue from your history.
          </p>
        `;
        clearAttachedFiles(); // ÏÉà Ìï®Ïàò Ìò∏Ï∂ú
      }
    };

    item.appendChild(textSpan);
    item.appendChild(deleteBtn);
    panel.appendChild(item);
  });

  let clearContainer = document.getElementById("history-clear-container");
  if (!clearContainer) {
    clearContainer = document.createElement("div");
    clearContainer.id = "history-clear-container";
    clearContainer.className = "mt-auto pt-2";
    document
      .querySelector(".w-80.flex.flex-col.p-4")
      .appendChild(clearContainer);
  }
  clearContainer.innerHTML = "";

  const clearBtn = document.createElement("button");
  clearBtn.textContent = "Clear History";
  clearBtn.className =
    "mt-4 min-w-[100%] px-3 py-1 bg-red-500 text-white rounded text-sm hover:bg-red-600 flex justify-center items-center";
  clearBtn.onclick = () => {
    localStorage.removeItem("chattron-history");
    sessionStorage.removeItem("current-session-id");
    panel.innerHTML = "";
    const chatPanel = document.getElementById("chat-panel");
    chatPanel.innerHTML = `
      <h2 class="text-[28px] font-bold text-center pt-5 pb-3 text-[#0d141c]">Welcome to ChatTron</h2>
      <p class="text-base font-normal text-center pb-3 pt-1 text-[#0d141c]">
        Start a new chat or continue from your history.
      </p>
    `;
    clearAttachedFiles(); // ÏÉà Ìï®Ïàò Ìò∏Ï∂ú
  };
  clearContainer.appendChild(clearBtn);
}

// Textarea ÏûêÎèô ÌÅ¨Í∏∞ Ï°∞Ï†à Ìï®ÏàòÎì§
function initializeTextareaAutoResize() {
  const textarea = document.getElementById("prompt-input");
  if (!textarea) return;

  function autoResize() {
    // Reset height to auto to get proper scrollHeight
    textarea.style.height = "auto";

    // Calculate new height (minimum 48px, maximum 200px)
    const newHeight = Math.max(48, Math.min(textarea.scrollHeight, 200));
    textarea.style.height = newHeight + "px";

    // Show/hide scrollbar when content exceeds max height
    if (textarea.scrollHeight > 200) {
      textarea.style.overflowY = "auto";
    } else {
      textarea.style.overflowY = "hidden";
    }
  }

  // Auto-resize on input
  textarea.addEventListener("input", autoResize);

  // Auto-resize on paste
  textarea.addEventListener("paste", function () {
    setTimeout(autoResize, 0);
  });

  // Reset textarea height after sending (Ï†ÑÏó≠ Ìï®ÏàòÎ°ú ÎÖ∏Ï∂ú)
  window.resetTextareaHeight = function () {
    textarea.value = "";
    autoResize();
  };

  // Initial resize on page load
  autoResize();

  return autoResize;
}

// MCP ÎèÑÍµ¨ Î™©Î°ùÏùÑ Í∞ÄÏ†∏ÏôÄÏÑú ÌëúÏãúÌïòÎäî Ìï®Ïàò
async function handleListMcpTools() {
  try {
    const activeClients = await window.mcpAPI.getClients();
    if (activeClients.length === 0) {
      renderMessage("No active MCP clients found.", "system");
      return;
    }

    let message = "Available MCP Tools:\n\n";

    for (const clientKey of activeClients) {
      try {
        const { tools } = await window.mcpAPI.listTools(clientKey);
        message += `[Client: ${clientKey}]\n`;
        if (tools && tools.length > 0) {
          tools.forEach(tool => {
            message += `- ${tool.name}: ${tool.description}\n`;
          });
        } else {
          message += "- No tools available\n";
        }
        message += "\n";
      } catch (err) {
        message += `[Client: ${clientKey}]\n- Error fetching tools: ${err.message}\n\n`;
      }
    }

    renderMessage(message, "assistant");

  } catch (err) {
    console.error("Failed to list MCP tools:", err);
    renderMessage("Error: " + err.message, "system");
  }
}

document.addEventListener("DOMContentLoaded", async () => {
  const settingsBtn = document.getElementById("settings-btn");
  const dropdownMenu = document.getElementById("dropdown-menu");
  const apiSettingsLink = document.getElementById("api-settings-link");
  const mcpSettingsBtn = document.getElementById("mcp-section");
  const newChatBtn = document.getElementById("new-chat");
  const input = document.getElementById("prompt-input");
  const sendBtn = document.getElementById("send-btn");
  const listMcpToolsBtn = document.getElementById("mcp-tool-list-btn");

  // Textarea ÏûêÎèô ÌÅ¨Í∏∞ Ï°∞Ï†à Ï¥àÍ∏∞Ìôî
  initializeTextareaAutoResize();

  // ÌîÑÎ°¨ÌîÑÌä∏ ÌååÏùº Î°úÎìú
  try {
    llmToolMatchingPrompt = await window.promptAPI.loadPrompt("../src/prompts/mcp_tool_matching_prompt.txt");
    if (!llmToolMatchingPrompt) {
      console.warn("LLM tool matching prompt file not loaded. Using hardcoded fallback.");
      llmToolMatchingPrompt = `
You are a tool-matching engine. Analyze the user's request and determine if it needs one tool or multiple tools.

RESPONSE FORMATS:

1. For SINGLE tool requests, return a JSON object:
{
  "client": "<client key>",
  "toolName": "<tool name>",
  "args": {
    "<arg1>": "...",
    ...
  }
}

2. For MULTIPLE tool requests, return a JSON ARRAY:
[
  {
    "client": "<client key>",
    "toolName": "<tool name>",
    "args": {
      "<arg1>": "...",
      ...
    }
  },
  {
    "client": "<client key>",
    "toolName": "<tool name>",
    "args": {
      "<arg1>": "...",
      ...
    }
  }
]

RULES:
- If the request involves sequential actions (like "do X then Y" or "go to A then B"), return an ARRAY
- If the request is a single action, return a single OBJECT
- DO NOT invent tool names or client keys
- You MUST choose ONLY from the available options below

Valid client keys:
{{CLIENT_LIST}}

Valid tool names:
{{TOOL_LIST}}

User request:
"{{USER_PROMPT}}"
`;
    }

    systemPrompt = await window.promptAPI.loadPrompt("../src/prompts/custom/custom-prompt.txt");
    if (!systemPrompt) {
      console.warn("System prompt file not loaded. Using hardcoded fallback.");
      systemPrompt = "You are a helpful assistant.";
    }
  } catch (err) {
    console.error("Error loading prompt files:", err);
    // Ïò§Î•ò Î∞úÏÉù Ïãú Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
    llmToolMatchingPrompt = `
You are a tool-matching engine. Analyze the user's request and determine if it needs one tool or multiple tools.

RESPONSE FORMATS:

1. For SINGLE tool requests, return a JSON object:
{
  "client": "<client key>",
  "toolName": "<tool name>",
  "args": {
    "<arg1>": "...",
    ...
  }
}

2. For MULTIPLE tool requests, return a JSON ARRAY:
[
  {
    "client": "<client key>",
    "toolName": "<tool name>",
    "args": {
      "<arg1>": "...",
      ...
    }
  },
  {
    "client": "<client key>",
    "toolName": "<tool name>",
    "args": {
      "<arg1>": "...",
      ...
    }
  }
]

RULES:
- If the request involves sequential actions (like "do X then Y" or "go to A then B"), return an ARRAY
- If the request is a single action, return a single OBJECT
- DO NOT invent tool names or client keys
- You MUST choose ONLY from the available options below

Valid client keys:
{{CLIENT_LIST}}

Valid tool names:
{{TOOL_LIST}}

User request:
"{{USER_PROMPT}}"
`;
    systemPrompt = "You are a helpful assistant.";
  }


  // Î©îÏù∏ Ïã§Ìñâ Î°úÏßÅÏùÑ Î≥ÑÎèÑ Ìï®ÏàòÎ°ú Î∂ÑÎ¶¨
  async function handlePromptSubmission() {
    let promptText = input.value.trim(); // ÏõêÎ≥∏ ÌÖçÏä§Ìä∏ ÌîÑÎ°¨ÌîÑÌä∏
    if (!promptText && uploadedFiles.length === 0) return;

    renderMessage(promptText || "[Attached File]", "user");
    input.value = "";

    // LLMÏóê Ï†ÑÏÜ°Ìï† ÏµúÏ¢Ö ÏΩòÌÖêÏ∏†Î•º Îã¥ÏùÑ Î∞∞Ïó¥ (ÌÖçÏä§Ìä∏ÏôÄ Ïù¥ÎØ∏ÏßÄÎ•º Î∂ÑÎ¶¨ÌïòÏó¨ Ï≤òÎ¶¨)
    const contentParts = [];

    if (promptText) {
        contentParts.push({ type: "text", text: promptText });
    }

    if (uploadedFiles.length > 0) {
      for (const file of uploadedFiles) {
        if (file.type.startsWith("text/") || file.type === "application/json") {
          // ÌÖçÏä§Ìä∏ Î∞è JSON ÌååÏùº Ï≤òÎ¶¨
          try {
            const reader = new FileReader();
            const content = await new Promise((resolve, reject) => {
              reader.onload = (e) => resolve(e.target.result);
              reader.onerror = (e) => reject(e);
              reader.readAsText(file); // ÌååÏùºÏùÑ ÌÖçÏä§Ìä∏Î°ú ÏùΩÍ∏∞
            });
            contentParts.push({
              type: "text",
              text: `\n\n--- Start of ${file.name} ---\n${content}\n--- End of ${file.name} ---`
            });
          } catch (error) {
            console.warn(`Failed to read text file ${file.name}:`, error);
            contentParts.push({
              type: "text",
              text: `\n\n--- Error reading ${file.name}: ${error.message} ---`
            });
          }
        } else if (file.type.startsWith("image/")) {
          // Ïù¥ÎØ∏ÏßÄ ÌååÏùº Ï≤òÎ¶¨ (Base64 Ïù∏ÏΩîÎî©)
          try {
            const reader = new FileReader();
            const dataUrl = await new Promise((resolve, reject) => {
              reader.onload = (e) => resolve(e.target.result);
              reader.onerror = (e) => reject(e);
              reader.readAsDataURL(file); // Ïù¥ÎØ∏ÏßÄÎ•º Data URL (Base64)Î°ú ÏùΩÍ∏∞
            });
            console.log(`Image ${file.name} read as Base64. Data URL: ${dataUrl.substring(0, 50)}...`);
            
            // Ïù¥Í≥≥ÏóêÏÑú LLM APIÏóê ÎßûÎäî Ïù¥ÎØ∏ÏßÄ ÌòïÏãùÏúºÎ°ú contentPartsÏóê Ï∂îÍ∞ÄÌï¥Ïïº Ìï©ÎãàÎã§.
            // ÏòàÎ•º Îì§Ïñ¥ OpenAIÏùò Í≤ΩÏö∞:
            // contentParts.push({ type: "image_url", image_url: { url: dataUrl } });
            
            // ÌòÑÏû¨Îäî ÏΩòÏÜîÏóê Ï∂úÎ†•Îßå ÌïòÍ≥†, LLM ÌîÑÎ°¨ÌîÑÌä∏ÏóêÎäî Ìè¨Ìï®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.
            // LLMÏù¥ Î©ÄÌã∞Î™®Îã¨ÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÍ±∞ÎÇò API ÌòïÏãùÏù¥ ÎßûÏßÄ ÏïäÏúºÎ©¥ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌï† Ïàò ÏûàÏäµÎãàÎã§.
            contentParts.push({
                type: "text",
                text: `\n\n--- Attached image: ${file.name} (type: ${file.type}). Base64 data read, but LLM API payload needs to be adjusted for multimodal input. ---`
            });

          } catch (error) {
            console.warn(`Failed to read image file ${file.name}:`, error);
            contentParts.push({
              type: "text",
              text: `\n\n--- Error reading image ${file.name}: ${error.message} ---`
            });
          }
        } else {
          // Í∏∞ÌÉÄ ÏßÄÏõêÌïòÏßÄ ÏïäÎäî ÌååÏùº ÌòïÏãù
          contentParts.push({
            type: "text",
            text: `\n\n--- Attached file: ${file.name} (type: ${file.type}). Content not included due to unsupported format. ---`
          });
        }
      }
    }

    // LLM payloadÏùò messages[0].content ÌïÑÎìúÎ•º Îã®Ïùº Î¨∏ÏûêÏó¥ ÎåÄÏã†
    // `contentParts` Î∞∞Ïó¥Î°ú Î≥ÄÍ≤ΩÌï¥Ïïº Ìï©ÎãàÎã§.
    // Ïù¥Îäî ÏÑ†ÌÉùÎêú LLM Ï†úÍ≥µÏóÖÏ≤¥Ïùò Î©ÄÌã∞Î™®Îã¨ API ÏÇ¨ÏñëÏóê Îî∞Îùº Îã¨ÎùºÏßëÎãàÎã§.
    // ÌòÑÏû¨ `payload` Íµ¨Ï°∞Îäî Îã®Ïùº Î¨∏ÏûêÏó¥ ÌîÑÎ°¨ÌîÑÌä∏Îßå Í∞ÄÏ†ïÌïòÎØÄÎ°ú,
    // ÏïÑÎûò `payload` Î≥ÄÏàò ÏÉùÏÑ± Î∂ÄÎ∂ÑÏùÑ LLM Ï†úÍ≥µÏóÖÏ≤¥Ïóê ÎßûÍ≤å Î≥ÄÍ≤ΩÌï¥Ïïº Ìï©ÎãàÎã§.
    // Ïòà: OpenAI ÏµúÏã† Î™®Îç∏Ïùò Í≤ΩÏö∞:
    // payload.messages[0].content = contentParts;
    // ...

    // ÏûÑÏãúÎ°ú, Î™®Îì† contentPartsÎ•º Îã®Ïùº Î¨∏ÏûêÏó¥Î°ú Í≤∞Ìï©ÌïòÏó¨ Í∏∞Ï°¥ prompt Î≥ÄÏàòÎ•º ÎåÄÏ≤¥Ìï©ÎãàÎã§.
    // Ïù¥Î†áÍ≤å ÌïòÎ©¥ Ïù¥ÎØ∏ÏßÄ Îç∞Ïù¥ÌÑ∞Í∞Ä ÌÖçÏä§Ìä∏Î°ú ÏßÅÎ†¨ÌôîÎêòÏñ¥ LLMÏóê Ï†ÑÎã¨ÎêòÏßÄÎßå,
    // LLMÏù¥ Ïù¥Î•º Ïù¥ÎØ∏ÏßÄÎ°ú Ïù∏ÏãùÌïòÏßÄ Î™ªÌïòÍ≥† Îã®ÏàúÌûà Î¨∏ÏûêÏó¥Î°ú Ï≤òÎ¶¨Ìï† Í≤ÉÏûÖÎãàÎã§.
    let finalPrompt = contentParts.map(part => part.text || '').join('');
    // ÎßåÏïΩ contentPartsÏóê ÌÖçÏä§Ìä∏Í∞Ä Ï†ÑÌòÄ ÏóÜÍ≥† Ïù¥ÎØ∏ÏßÄ ÌååÌä∏Îßå ÏûàÎã§Î©¥, Í∏∞Î≥∏ Î©îÏãúÏßÄ Ï∂îÍ∞Ä
    if (!finalPrompt && contentParts.some(part => part.type.startsWith('image/'))) {
        finalPrompt = "[Image attached. Model needs multimodal support to process this.]";
    }
    if (!finalPrompt) return; // Î™®Îì† ÏΩòÌÖêÏ∏†Í∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ Ï†ÑÏÜ°ÌïòÏßÄ ÏïäÏùå

    // Ïù¥Ï†ú 'prompt' ÎåÄÏã† 'finalPrompt'Î•º LLMÏóê Ï†ÑÎã¨Ìï¥Ïïº Ìï©ÎãàÎã§.
    // ÏïÑÎûò payload ÏÉùÏÑ± Î∂ÄÎ∂ÑÏóêÏÑú prompt ÎåÄÏã† finalPromptÎ•º ÏÇ¨Ïö©ÌïòÎèÑÎ°ù Î≥ÄÍ≤ΩÌï©ÎãàÎã§.
    // ...

    // Î°úÎî© ÏÉÅÌÉú ÌëúÏãú
    let loadingMessage = null;
    try {
      loadingMessage = renderMessage("ü§î Thinking...", "system");
    } catch (err) {
      console.warn("Could not create loading message:", err);
    }

    // ÏïàÏ†ÑÌïú Î°úÎî© Î©îÏãúÏßÄ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
    function updateLoadingMessage(text) {
      if (loadingMessage && loadingMessage.textContent !== undefined) {
        loadingMessage.textContent = text;
      }
    }

    // ÏïàÏ†ÑÌïú Î°úÎî© Î©îÏãúÏßÄ Ï†úÍ±∞ Ìï®Ïàò
    function removeLoadingMessage() {
      if (loadingMessage && loadingMessage.parentNode) {
        loadingMessage.remove();
      }
    }

    try {
      let match = findMatchingTool(finalPrompt); // LLM Ìà¥ Îß§Ïπ≠ÏóêÎèÑ finalPrompt ÏÇ¨Ïö©

      // ÏûêÏó∞Ïñ¥ Í∏∞Î∞ò MCP Ìà¥ Îß§Ïπ≠ (fallback)
      if (!match) {
        console.log("üîç No direct tool match found, trying LLM matching...");

        updateLoadingMessage("üß† Analyzing request with LLM...");

        const llmMatch = await findToolViaLLM(finalPrompt, mcpToolRegistry); // LLM Îß§Ïπ≠ÏóêÎèÑ finalPrompt ÏÇ¨Ïö©

        if (llmMatch) {
          console.log("‚úÖ LLM found tool match:", llmMatch);

          // Îã§Ï§ë ÎèÑÍµ¨ Ï≤òÎ¶¨
          if (llmMatch.isMultiple) {
            console.log(
              `üîÑ Multiple tools detected (${llmMatch.totalCount} tools)`
            );

            // Î°úÎî© Î©îÏãúÏßÄ Ï†úÍ±∞
            removeLoadingMessage();

            // Îã§Ï§ë ÎèÑÍµ¨ Ïã§Ìñâ
            await executeMultipleTools(llmMatch, finalPrompt); // Îã§Ï§ë ÎèÑÍµ¨ Ïã§ÌñâÏóêÎèÑ finalPrompt ÏÇ¨Ïö©
            return;
          }
          // Îã®Ïùº ÎèÑÍµ¨ Ï≤òÎ¶¨ (Í∏∞Ï°¥ Î∞©Ïãù)
          else if (llmMatch.client && llmMatch.toolName) {
            const toolList = mcpToolRegistry[llmMatch.client] || [];
            const tool = toolList.find((t) => t.name === llmMatch.toolName);
            if (tool) {
              match = {
                client: llmMatch.client,
                tool,
                args:
                  llmMatch.args ||
                  extractArgsFromPrompt(finalPrompt, tool.inputSchema), // Ïù∏Ïûê Ï∂îÏ∂úÏóêÎèÑ finalPrompt ÏÇ¨Ïö©
              };
            }
          }
        }

        if (!match && !llmMatch?.isMultiple) {
          console.log("‚ùå LLM could not find a suitable tool match");
        }
      }

      // Î°úÎî© Î©îÏãúÏßÄ Ï†úÍ±∞
      removeLoadingMessage();

      // Îã®Ïùº MCP Ïã§Ìñâ (Í∏∞Ï°¥ Î∞©Ïãù)
      if (match) {
        console.log("üõ†Ô∏è Executing single MCP tool...");
        const executingMessage = renderMessage(
          "üõ†Ô∏è Executing tool...",
          "system"
        );

        try {
          const args =
            match.args || extractArgsFromPrompt(finalPrompt, match.tool.inputSchema); // Ïù∏Ïûê Ï∂îÏ∂úÏóêÎèÑ finalPrompt ÏÇ¨Ïö©

          console.log("MCP CALL DEBUG", {
            client: match.client,
            name: match.tool.name,
            args,
          });

          const result = await window.mcpAPI.callTool({
            client: match.client,
            name: match.tool.name,
            args,
          });

          // Ïã§Ìñâ Î©îÏãúÏßÄ Ï†úÍ±∞
          if (executingMessage && executingMessage.parentNode) {
            executingMessage.remove();
          }

          renderMessage(
            `[MCP:${match.client}] ${JSON.stringify(result, null, 2)}`,
            "assistant"
          );
          saveToHistory(finalPrompt, JSON.stringify(result)); // ÌûàÏä§ÌÜ†Î¶¨ÏóêÎèÑ finalPrompt Ï†ÄÏû•
        } catch (err) {
          console.error("MCP execution error:", err);

          // Ïã§Ìñâ Î©îÏãúÏßÄ Ï†úÍ±∞
          if (executingMessage && executingMessage.parentNode) {
            executingMessage.remove();
          }

          renderMessage("MCP Error: " + err.message, "system");
        }
        return;
      }

      // fallback: LLM chat (Í∏∞Ï°¥ ÏΩîÎìúÏôÄ ÎèôÏùº)
      console.log("üí¨ Falling back to direct LLM chat...");
      const chatMessage = renderMessage(
        "üí¨ Using direct LLM chat...",
        "system"
      );

      const settings =
        window.settingsAPI?.load?.() ||
        JSON.parse(localStorage.getItem("chattron-settings") || "{}");

      const { apiUrl, modelName, apiKey, provider } = settings;
      if (!apiUrl || !modelName || !provider) {
        // Ï±ó Î©îÏãúÏßÄ Ï†úÍ±∞
        if (chatMessage && chatMessage.parentNode) {
          chatMessage.remove();
        }
        renderMessage("‚ùå API setting is missing.", "system");
        return;
      }

      let payload = {};
      let reply = "";

      try {
        switch (provider) {
          case "openai":
          case "ollama":
          case "localfastapi":
          case "custom":
            payload = {
              model: modelName,
              messages: [
                { role: "system", content: systemPrompt }, // Î°úÎìúÎêú systemPrompt ÏÇ¨Ïö©
                { role: "user", content: finalPrompt }, // <-- finalPrompt ÏÇ¨Ïö©
              ],
              stream: false,
            };
            break;
          case "anthropic":
            payload = {
              model: modelName,
              messages: [{ role: "user", content: finalPrompt }], // <-- finalPrompt ÏÇ¨Ïö©
              stream: false,
              max_tokens: 1024,
            };
            break;
          default:
            if (chatMessage && chatMessage.parentNode) {
              chatMessage.remove();
            }
            renderMessage("‚ùå Unsupported provider.", "system");
            return;
        }

        const headers = {
          "Content-Type": "application/json",
          ...(apiKey && { Authorization: `Bearer ${apiKey}` }),
        };

        console.log("üì§ Sending direct LLM request...");
        const startTime = Date.now();

        const res = await fetch(apiUrl, {
          method: "POST",
          headers,
          body: JSON.stringify(payload),
        });

        const responseTime = Date.now() - startTime;
        console.log(`üì• LLM response received in ${responseTime}ms`);

        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(`HTTP ${res.status}: ${errorText}`);
        }

        const data = await res.json();
        console.log("üìã LLM response data:", data);

        switch (provider) {
          case "openai":
            reply = data.choices?.[0]?.message?.content || "No response";
            break;
          case "ollama":
            reply = data.message?.content || data.response || "No response";
            break;
          case "anthropic":
            reply = data.content || "No response";
            break;
          case "localfastapi":
          case "custom":
            reply =
              data.choices?.[0]?.message?.content ||
              data.message?.content ||
              data.content ||
              data.response ||
              data.text ||
              (typeof data === "string" ? data : JSON.stringify(data));
            break;
        }

        // Ï±ó Î©îÏãúÏßÄ Ï†úÍ±∞
        if (chatMessage && chatMessage.parentNode) {
          chatMessage.remove();
        }

        renderMessage(reply, "assistant");
        saveToHistory(finalPrompt, reply); // ÌûàÏä§ÌÜ†Î¶¨ÏóêÎèÑ finalPrompt Ï†ÄÏû•
      } catch (err) {
        console.error("üí• Direct LLM chat error:", err);

        // Ï±ó Î©îÏãúÏßÄ Ï†úÍ±∞
        if (chatMessage && chatMessage.parentNode) {
          chatMessage.remove();
        }

        renderMessage(
          "‚ùå Error occurred during API request: " + err.message,
          "system"
        );
      }
    } catch (err) {
      console.error("üí• General error in send handler:", err);

      // Î™®Îì† Î°úÎî© Î©îÏãúÏßÄ Ï†úÍ±∞
      removeLoadingMessage();
      const systemMessages = document.querySelectorAll(".bg-yellow-100");
      systemMessages.forEach((msg) => {
        if (
          msg.textContent.includes("ü§î") ||
          msg.textContent.includes("üß†") ||
          msg.textContent.includes("üõ†Ô∏è") ||
          msg.textContent.includes("üí¨")
        ) {
          msg.remove();
        }
      });

      renderMessage(
        "‚ùå An unexpected error occurred: " + err.message,
        "system"
      );
    } finally {
      // ÏÑ±Í≥µ/Ïã§Ìå® Ïó¨Î∂ÄÏôÄ Í¥ÄÍ≥ÑÏóÜÏù¥ Ï†ÑÏÜ° Ïãú ÌååÏùº Ï¥àÍ∏∞Ìôî
      clearAttachedFiles();
    }
  }

  // Í∏∞Ï°¥ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨Îì§

  newChatBtn?.addEventListener("click", () => {
    // 1. Í∏∞Ï°¥ ÏÑ∏ÏÖò ID Ï†úÍ±∞ (ÏÑ∏ÏÖòÏùÑ ÎπÑÏõå ÏÉàÎ°ú ÏãúÏûë)
    sessionStorage.removeItem("current-session-id");

    // 2. chat-panel Welcome Î©îÏãúÏßÄ Î≥µÏõê
    const chatPanel = document.getElementById("chat-panel");
    if (chatPanel) {
      chatPanel.innerHTML = `
      <h2 class="text-[28px] font-bold text-center pt-5 pb-3 text-[#0d141c]">Welcome to ChatTron</h2>
      <p class="text-base font-normal text-center pb-3 pt-1 text-[#0d141c]">
        Start a new chat or continue from your history.
      </p>
    `;
    }

    // 3. ÏûÖÎ†•Ï∞Ω Ï¥àÍ∏∞Ìôî
    input.value = "";

    // 4. ÌûàÏä§ÌÜ†Î¶¨ UI Í∞±Ïã†
    updateHistoryUI();

    // 5. ÌååÏùº Î™©Î°ù Ï¥àÍ∏∞Ìôî
    clearAttachedFiles(); // ÏÉà Ìï®Ïàò Ìò∏Ï∂ú

    console.log(
      "New Chat UI reset. Session ID will be created on first message."
    );
  });

  settingsBtn?.addEventListener("click", (e) => {
    e.stopPropagation();
    dropdownMenu?.classList.toggle("hidden");
  });

  document.addEventListener("click", () => {
    dropdownMenu?.classList.add("hidden");
  });

  apiSettingsLink?.addEventListener("click", () => {
    window.location.href = "settings.html";
  });

  mcpSettingsBtn?.addEventListener("click", () => {
    sessionStorage.removeItem("selected-mcp-key");
    window.location.href = "mcp.html";
  });

  try {
    window.mcpBridgeAPI?.launchBridge();
  } catch (err) {
    alert("MCP Agent ÏûêÎèô Ïã§Ìñâ Ïã§Ìå®: " + err.message);
    console.warn("MCP Agent ÏûêÎèô Ïã§Ìñâ Ïã§Ìå®:", err.message);
  }

  console.log("üöÄ Initializing ChatTron...");

  try {
    await syncMCPState();
    loadHistory();
    updateHistoryUI();
    // Ï¥àÍ∏∞Ìôî Ïãú ÌååÏùº UIÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
    clearAttachedFiles(); // ÏÉà Ìï®Ïàò Ìò∏Ï∂ú
    console.log("‚úÖ ChatTron initialization complete");
  } catch (error) {
    console.error("‚ùå Initialization failed:", error);
    await buildMCPRegistry();
    updateMCPUI();
    loadHistory();
    updateHistoryUI();
    // Ï¥àÍ∏∞Ìôî Ïãú ÌååÏùº UIÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
    clearAttachedFiles(); // ÏÉà Ìï®Ïàò Ìò∏Ï∂ú
  }

  // Send Î≤ÑÌäº ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏
  sendBtn?.addEventListener("click", handlePromptSubmission);
  
  // MCP ÎèÑÍµ¨ Î™©Î°ù Î≤ÑÌäº ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏
  listMcpToolsBtn?.addEventListener("click", handleListMcpTools);


  // Enter ÌÇ§ Ïù¥Î≤§Ìä∏ Ìï∏Îì§Îü¨ Ï∂îÍ∞Ä
  input?.addEventListener("keydown", (event) => {
    // Enter ÌÇ§Í∞Ä ÎàåÎ†∏ÏùÑ Îïå (Shift+EnterÎäî Ï†úÏô∏)
    if (event.key === "Enter" && !event.shiftKey) {
      event.preventDefault(); // Í∏∞Î≥∏ Enter ÎèôÏûë Î∞©ÏßÄ (Ï§ÑÎ∞îÍøà Î∞©ÏßÄ)
      handlePromptSubmission();
    }

    // Shift+EnterÎäî Ï§ÑÎ∞îÍøàÏùÑ ÌóàÏö© (inputÏù¥ textareaÏù∏ Í≤ΩÏö∞)
    // Î≥ÑÎèÑ Ï≤òÎ¶¨ Î∂àÌïÑÏöî - Í∏∞Î≥∏ ÎèôÏûëÏù¥ Ï§ÑÎ∞îÍøà
  });

  // ÌòÑÏû¨ ÏÑ§Ï†ï ÌëúÏãú (Í∏∞Ï°¥ ÏΩîÎìú)
  const settings =
    window.settingsAPI?.load?.() ||
    JSON.parse(localStorage.getItem("chattron-settings") || "{}");

  if (settings.apiUrl || settings.modelName || settings.provider) {
    const settingsDiv = document.getElementById("current-settings");
    if (settingsDiv) {
      settingsDiv.innerHTML = `
        <div class="text-gray-500 text-xs mt-1">
          <div><strong>Provider:</strong> ${settings.provider}</div>
          <div><strong>API URL:</strong> ${settings.apiUrl}</div>
          <div><strong>Model:</strong> ${settings.modelName}</div>
        </div>
      `;
    }
  }
});